---
description: Technical guidelines and best practices for Project Leroy development
alwaysApply: true
tags:
  - technical-guidelines
  - python
  - raspberry-pi
  - opencv
  - edge-ai
  - project-leroy
---

# Project Leroy - Technical Guidelines

## Code Organization

### File Structure
- **Main scripts**: `leroy.py` - Main detection script (Hailo AI Kit)
- **Core modules**: `common.py`, `visitations.py`, `photo.py` - Shared functionality
- **AI Inference**: `hailo_inference.py` - Hailo AI Kit inference abstraction
- **Classification**: `classify.py` - Bird classification pipeline
- **Services**: `service/leroy.service` - Systemd service configuration
- **Web interface**: `web/` - React frontend for viewing results

### Naming Conventions
- **Scripts**: `leroy-*.py` for hardware-specific variants
- **Modules**: lowercase with underscores (`visitations.py`, `common.py`)
- **Classes**: PascalCase (`Visitations`, `Visitation`)
- **Functions**: snake_case (`add_padding_to_bbox`, `get_output`)
- **Constants**: UPPER_SNAKE_CASE

## Python Standards

### Type Hints
```python
from typing import List, Tuple, Optional
import numpy as np
from PIL import Image

def process_frame(frame: np.ndarray, threshold: float = 0.5) -> Optional[np.ndarray]:
    """Process a single frame for object detection."""
    pass
```

### Error Handling
- Always use specific exception types
- Log exceptions with context
- Gracefully degrade on hardware failures
- Never use bare `except:`

```python
try:
    ret, frame = cap.read()
    if not ret:
        logging.warning("Failed to read frame from camera")
        continue
except cv2.error as e:
    logging.error(f"OpenCV error: {e}")
    # Attempt recovery or graceful shutdown
except Exception as e:
    logging.exception("Unexpected error in frame capture")
    raise
```

### Resource Management
- Always release OpenCV VideoCapture
- Use context managers for file operations
- Clean up systemd service resources
- Monitor memory usage

```python
# Good: Context manager for file operations
with open(path, 'r') as f:
    data = f.read()

# Good: Explicit cleanup
cap = cv2.VideoCapture(0)
try:
    # Use camera
    pass
finally:
    cap.release()
    cv2.destroyAllWindows()
```

## OpenCV Best Practices

### Camera Initialization
```python
# Set resolution before reading frames
cap = cv2.VideoCapture(camera_idx)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 2048)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1536)

# Verify camera is opened
if not cap.isOpened():
    raise RuntimeError(f"Failed to open camera {camera_idx}")
```

### Frame Processing
- Resize frames efficiently (use imutils for consistent aspect ratio)
- Convert color spaces only when necessary
- Avoid unnecessary copies
- Use NumPy operations for batch processing

```python
# Efficient resizing
resized_frame = imutils.resize(frame, width=500)

# Color space conversion only when needed
rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
pil_image = Image.fromarray(rgb_frame)
```

### Memory Management
- Release VideoCapture when done
- Destroy all windows
- Avoid storing large frame arrays unnecessarily
- Use frame skipping for high FPS scenarios

## Scientific Names

### Dynamic Lookup Approach

**No Static File Required**: Scientific names are extracted dynamically from classification labels or looked up as needed.

**Implementation**:
- Tries to extract from labels file if format includes scientific names: `1 american-robin (Turdus migratorius)`
- Falls back to "Unknown" if not found (system still works)
- Future: Can add API lookup (eBird/iNaturalist) if needed

**Benefits**:
- ✅ No static file to maintain
- ✅ Works with current labels (scientific name = "Unknown")
- ✅ Works with enhanced labels (extracts scientific names)
- ✅ Flexible for future API integration

---

## Edge AI Integration

### Hailo AI Kit Integration

**Priority**: Always use Raspberry Pi's official tools and SDKs for AI Kit integration.

```python
# Hailo AI Kit inference using official Raspberry Pi SDK
from hailo_platform import Device, InferVStreams, InferModel
from PIL import Image
import numpy as np

class HailoInference:
    """Hailo AI Kit inference using official Raspberry Pi SDK."""
    def __init__(self):
        self.device = Device()
        self.network_group = None
    
    def load_model(self, model_path: str) -> None:
        """Load HEF model from official Hailo SDK."""
        self.network_group = self.device.load_model(model_path)
    
    def detect(self, image: Image.Image) -> List[Detection]:
        """Run detection inference."""
        with InferVStreams(self.network_group) as infer_pipeline:
            # Preprocess image for model input
            input_data = self._preprocess(image)
            results = infer_pipeline.infer(input_data)
            return self._postprocess_detection(results)
    
    def classify(self, image: Image.Image) -> List[Classification]:
        """Run classification inference."""
        with InferVStreams(self.network_group) as infer_pipeline:
            input_data = self._preprocess(image)
            results = infer_pipeline.infer(input_data)
            return self._postprocess_classification(results)
```

### Model Loading
- Load models once at startup
- Use HEF format models (converted via Hailo Dataflow Compiler)
- Verify model compatibility with Hailo-8L accelerator
- Handle model loading failures gracefully
- Support model versioning

### Inference Optimization
- Preprocess images efficiently for Hailo models
- Batch inference when possible (Hailo supports better batching)
- Cache preprocessed inputs
- Monitor inference latency
- Use official Raspberry Pi tools (rpicam-apps, Hailo SDK)

## Logging Standards

### Structured Logging
```python
import logging

logging.basicConfig(
    filename='storage/results.log',
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.DEBUG
)

logger = logging.getLogger(__name__)

# Use appropriate log levels
logger.debug("Detailed debugging information")
logger.info("General information")
logger.warning("Warning message")
logger.error("Error occurred")
logger.exception("Exception with traceback")
```

### Log Context
- Include timestamps
- Log hardware state (temperature, memory)
- Log model inference results
- Log visitation lifecycle events

## Visitation Tracking

### Lifecycle Management
- Track visitation start/end times
- Limit photo count per visitation
- Handle visitation timeouts
- Reset state properly

```python
class Visitations:
    def reset(self):
        """Reset visitation state and cleanup resources."""
        logging.info(f"Visitation {self.visitation_id} ended")
        self.photo_per_visitation_count = 0
        self.full_photo_per_visitation_count = 0
        self.visitation_id = None
        # Cleanup any open resources
```

### Photo Capture
- Use consistent naming conventions
- Organize by date and visitation ID
- Add metadata to filenames (confidence, label)
- Handle storage full scenarios

## Systemd Service Configuration

### Service File Best Practices
```ini
[Unit]
Description=Project Leroy Bird Detection Service
After=multi-user.target network.target

[Service]
Type=simple
User=leroy
WorkingDirectory=/home/leroy/Projects/project-leroy
ExecStart=/home/leroy/Projects/project-leroy/run.sh
Restart=on-failure
RestartSec=10
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

### Environment Variables
- Use `.env` files for configuration
- Don't hardcode paths
- Support different hardware configurations
- Document required environment variables

## Performance Optimization

### Frame Rate Management
- Skip frames if processing is slow
- Use threading for I/O operations
- Monitor FPS and adjust accordingly
- Log performance metrics

### Memory Optimization
- Avoid storing full-resolution frames unnecessarily
- Use object pooling for repeated operations
- Monitor memory usage
- Handle out-of-memory gracefully

### Thermal Management
- Monitor CPU/GPU temperature
- Throttle processing if overheating
- Log thermal events
- Consider cooling solutions

## Testing Guidelines

### Unit Tests
- Test core logic (detection, classification, tracking)
- Mock hardware dependencies
- Test error handling paths
- Test edge cases

### Integration Tests
- Test on actual hardware when possible
- Test camera initialization
- Test model loading
- Test service startup/shutdown

### Performance Tests
- Measure inference latency
- Monitor memory usage over time
- Test under load
- Profile bottlenecks

## Hardware-Specific Considerations

### Raspberry Pi 5 Hardware
- **CPU**: ARMv8, 2.4GHz quad-core
- **RAM**: 4GB or 8GB LPDDR4X
- **USB**: 3.0 (5 Gbps) + USB 2.0
- **PCIe 2.0**: For AI Kit connection
- **Camera**: Pi Camera v3 or USB webcam
- **Storage**: SD card or NVMe (via PCIe)

### Raspberry Pi AI Kit
- **Hailo-8L Accelerator**: 13 TOPS performance
- **Interface**: PCIe 2.0 (native integration via M.2 HAT+)
- **Model Format**: HEF (Hailo Executable Format)
- **Official SDK**: Hailo Python SDK from Raspberry Pi repositories
- **Installation**: Follow official Raspberry Pi AI Kit installation guide

### Camera Compatibility
- Support both Pi Camera and USB webcams
- Handle different resolutions
- Test with various camera models
- Document supported configurations

## Security Considerations

### File Permissions
- Restrict write access to storage directories
- Use proper user/group permissions
- Secure web interface
- Protect sensitive configuration

### Network Security
- Use SSH keys, not passwords
- Keep system updated
- Firewall configuration
- Secure web interface (HTTPS if exposed)

## Documentation Requirements

### Code Documentation
- Docstrings for all public functions
- Type hints for function signatures
- Comments for complex logic
- README for setup instructions

### Architecture Documentation
- System overview diagram
- Data flow documentation
- Hardware configuration guide
- Troubleshooting guide

---

**Remember**: Code should be reliable, maintainable, and optimized for continuous operation on resource-constrained hardware.
